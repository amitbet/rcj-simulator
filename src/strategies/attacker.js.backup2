// ============================================================
// RoboCup Jr. Simulator - Attacker Strategy (State Machine)
// ============================================================
// Motor layout (viewed from above, robot facing up):
//   motor1 (front-left)    motor2 (front-right)
//          [    KICKER    ]  ← FRONT (forward direction)
//   motor4 (back-left)     motor3 (back-right)
//
// Omni wheels at 45-degree angles (diamond pattern from Arduino code):
// Forward kinematics: m1 = vx + vy + omega, m2 = -vx + vy + omega, m3 = vx - vy - omega, m4 = -vx - vy - omega
// Where: vx = forward/backward (forward = +), vy = left/right (right = +), omega = rotation (CW = +)
//
// Movement patterns:
//   - Forward: vx > 0, vy = 0, omega = 0
//   - Backward: vx < 0, vy = 0, omega = 0
//   - Strafe right: vx = 0, vy > 0, omega = 0
//   - Strafe left: vx = 0, vy < 0, omega = 0
//   - Rotate CW: vx = 0, vy = 0, omega > 0
//   - Rotate CCW: vx = 0, vy = 0, omega < 0

// ============================================================
// STATE MACHINE STATES
// ============================================================
const STATE = {
  SEARCHING: 'SEARCHING',
  ATTACKING: 'ATTACKING',
  UNCROSSING_LINE: 'UNCROSSING_LINE',
  STUCK: 'STUCK',
  RESET_POSITION: 'RESET_POSITION'
};

// Current state
var currentState = STATE.SEARCHING;

// Current target (for display)
var currentTarget = null;

// State-specific persistent variables
var searchTime = 0;
var lastBallVisible = true;

// Line detection control
var ignoreLineDetection = false; // Single boolean to ignore all line detection

// Line crossing state
var backoffDistance = 0; // cm moved in reverse direction so far
var reverseDirection = { x: 0, y: 0 }; // Direction to reverse (normalized)
const BACKOFF_TARGET_CM = 10; // Move 10cm in opposite direction before resuming

// Reset position tracking - track stuck/uncrossing events
var resetEvents = []; // Array of { time: number, type: 'stuck' | 'uncrossing' }
const RESET_EVENT_WINDOW_MS = 5000; // 5 seconds window
const RESET_EVENT_THRESHOLD = 3; // Need 3 events within window to trigger reset
var stuckEntryTime = null; // Track when we entered STUCK state to prevent rapid oscillation
const MIN_STUCK_TIME_MS = 300; // Minimum time to stay in STUCK state before allowing exit
var resetTargetGoalIsBlue = null; // true = blue goal, false = yellow goal, null = not set
var resetDistanceMoved = 0; // Track distance moved toward target goal during RESET_POSITION (cm)
var resetInitialDistance = null; // Initial distance to goal when entering RESET_POSITION
var resetRotationAccumulated = 0; // Track accumulated rotation during RESET_POSITION (degrees)
var resetLastHeading = null; // Track last heading to calculate rotation

// Line sensor memory - remember when line was detected and direction
var lineSensorMemory = {
  front: { active: false, direction: null },
  left: { active: false, direction: null },
  right: { active: false, direction: null },
  rear: { active: false, direction: null }
};

// Line sensor trigger tracking - turn to own goal after 3 triggers
var lineTriggerCounts = { front: 0, left: 0, right: 0, rear: 0 };
var lastLineState = { front: false, left: false, right: false, rear: false };
var turningToOwnGoal = false;
var ownGoalTurnComplete = false;
var distanceMovedToGoal = 0; // Track distance moved towards own goal
const GOAL_ADVANCE_DISTANCE_CM = 50; // Move 50cm towards own goal

function strategy(worldState) {
  const { ball, goal_blue, goal_yellow, we_are_blue, bumper_front, bumper_left, bumper_right, 
          line_front, line_left, line_right, line_rear, stuck, t_ms, dt_s } = worldState;
  
  // Target goal (opponent's goal - where we want to kick the ball)
  const targetGoal = we_are_blue ? goal_yellow : goal_blue;
  // Own goal (the one we're defending - must avoid scoring here!)
  const ownGoal = we_are_blue ? goal_blue : goal_yellow;
  
  let motor1 = 0, motor2 = 0, motor3 = 0, motor4 = 0;
  let kick = false;
  
  // Helper: set all motors (deprecated - use movementToMotors instead)
  function setMotors(fl, fr, br, bl) {
    motor1 = fl; motor2 = fr; motor3 = br; motor4 = bl;
  }
  
  // Helper: turn in place (positive = turn right/CW)
  // REVERTED: Using differential drive pattern that worked for rotation tests
  // CW: leftSide negative, rightSide positive (leftSide < rightSide)
  // CCW: leftSide positive, rightSide negative (leftSide > rightSide)
  function turn(speed) {
    if (speed > 0) {
      // Rotate CW: leftSide negative, rightSide positive
      motor1 = -speed;  // left front
      motor4 = -speed;  // left back
      motor2 = speed;   // right front
      motor3 = speed;   // right back
    } else if (speed < 0) {
      // Rotate CCW: leftSide positive, rightSide negative
      motor1 = -speed;  // left front (positive)
      motor4 = -speed;  // left back (positive)
      motor2 = speed;   // right front (negative)
      motor3 = speed;   // right back (negative)
    } else {
      // No rotation
      motor1 = 0;
      motor2 = 0;
      motor3 = 0;
      motor4 = 0;
    }
  }
  
  // Helper: drive forward/backward
  // REVERTED: Using differential drive pattern that worked for rectangle tests
  // Forward: both sides positive (leftSide = rightSide > 0)
  function drive(speed) {
    motor1 = speed;  // left front
    motor4 = speed;  // left back
    motor2 = speed;  // right front
    motor3 = speed;  // right back
  }
  
  // Helper: strafe (positive = move right)
  // REVERTED: Using differential drive pattern - strafe by turning and moving forward
  // For true strafe with differential drive, we need to turn 90° then drive
  // But for now, use a pattern that approximates strafe: leftSide and rightSide opposite
  // This will cause rotation, but combined with forward movement it can approximate strafe
  function strafe(speed) {
    // Approximate strafe: turn slightly while moving forward
    // This is not true strafe but works with differential drive
    const turnAmount = speed * 0.3; // Small turn component
    motor1 = speed - turnAmount;  // left front
    motor4 = speed - turnAmount;  // left back
    motor2 = speed + turnAmount;  // right front
    motor3 = speed + turnAmount;  // right back
  }
  
  // Helper: clamp value
  function clamp(val, min, max) {
    return Math_max(min, Math_min(max, val));
  }
  
  // Helper: Convert desired movement to differential drive motor speeds
  // REVERTED: Using differential drive interpretation that worked for rectangle/diamond/rotation tests
  // vx = forward/backward (forward = +), omega = rotation (CW = +, CCW = -)
  // For differential drive: leftSide = vx - omega, rightSide = vx + omega
  // Motor mapping: m1,m4 = leftSide, m2,m3 = rightSide
  function movementToMotors(vx, vy, omega) {
    // For differential drive, vy (strafe) is not directly supported
    // Convert vy to a rotation component: strafe right = turn right while moving forward
    const leftSide = vx - omega + (vy * 0.3);  // Add small turn component for strafe
    const rightSide = vx + omega - (vy * 0.3);
    
    return {
      motor1: clamp(leftSide, -1, 1),   // left front
      motor2: clamp(rightSide, -1, 1),   // right front
      motor3: clamp(rightSide, -1, 1),   // right back
      motor4: clamp(leftSide, -1, 1)     // left back
    };
  }
  
  // Helper: Strafe at any angle while maintaining forward orientation
  // REVERTED: For differential drive, strafe is approximated by turning and moving
  // angle_deg: angle in degrees (0 = forward, 90 = right, -90 = left, 180 = backward)
  // speed: movement speed (0..1)
  // omega: optional rotation speed (default 0 to maintain orientation)
  function strafeAtAngle(angle_deg, speed, omega = 0) {
    // Convert angle to forward/backward and turn components
    const angle_rad = angle_deg * Math_PI / 180;
    const vx = speed * Math_cos(angle_rad);
    const turnComponent = speed * Math_sin(angle_rad) * 0.5; // Convert strafe to turn
    return movementToMotors(vx, 0, omega + turnComponent);
  }
  
  // ============================================================
  // STATE: RESET_POSITION (Ignore all lines, navigate to furthest goal)
  // ============================================================
  if (currentState === STATE.RESET_POSITION) {
    // Ignore all line detection
    ignoreLineDetection = true;
    
    // Lock onto the furthest goal when first entering this state
    if (resetTargetGoalIsBlue === null) {
      // Find the goal that is furthest from the robot's current position
      // Compare distances (always calculated, even if not visible)
      if (goal_blue.distance > goal_yellow.distance) {
        resetTargetGoalIsBlue = true;
        currentTarget = 'blue goal';
        resetInitialDistance = goal_blue.distance;
      } else {
        resetTargetGoalIsBlue = false;
        currentTarget = 'yellow goal';
        resetInitialDistance = goal_yellow.distance;
      }
      // Reset rotation tracking (not needed for omni but kept for compatibility)
      resetRotationAccumulated = 0;
      resetLastHeading = null;
      resetDistanceMoved = 0; // Reset distance tracking
    }
    
    // Always set target to goal (never ball) in RESET_POSITION
    currentTarget = resetTargetGoalIsBlue ? 'blue goal' : 'yellow goal';
    
    // Get fresh distance from current goal observations (they update each frame)
    const furthestGoalDist = resetTargetGoalIsBlue ? goal_blue.distance : goal_yellow.distance;
    const furthestGoalVis = resetTargetGoalIsBlue ? goal_blue.visible : goal_yellow.visible;
    const furthestGoalAngle = resetTargetGoalIsBlue ? goal_blue.angle_deg : goal_yellow.angle_deg;
    
    // Calculate distance moved toward goal (difference from initial distance)
    // Only update if goal is visible - if not visible, keep last known value
    if (resetInitialDistance !== null && furthestGoalVis) {
      resetDistanceMoved = resetInitialDistance - furthestGoalDist;
      // Ensure distance moved is non-negative (we're moving toward goal, not away)
      if (resetDistanceMoved < 0) {
        resetDistanceMoved = 0; // Reset if we somehow moved away
      }
    }
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:145',message:'RESET_POSITION distance tracking',data:{resetInitialDistance,furthestGoalDist,resetDistanceMoved,furthestGoalVis,exitCondition60:resetDistanceMoved >= 60},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'Q'})}).catch(()=>{});
    // #endregion
    
    // Exit reset after moving 60cm toward the target goal
    // REMOVED fallback condition - we should only exit after moving 60cm, not when reaching goal
    // This ensures we move exactly 60cm toward the goal, regardless of how close we get
    if (resetDistanceMoved >= 60) {
      ignoreLineDetection = false;
      resetEvents = []; // Clear reset events
      resetTargetGoalIsBlue = null; // Clear locked goal
      resetRotationAccumulated = 0;
      resetLastHeading = null;
      resetDistanceMoved = 0;
      resetInitialDistance = null;
      // Transition to ATTACKING state (attacker preference)
      currentState = STATE.ATTACKING;
      return { motor1, motor2, motor3, motor4, kick };
    }
    
    // Move toward goal using differential drive (turn + forward)
    // Physics engine uses differential drive, not true omnidirectional
    if (furthestGoalVis) {
      // Goal is visible - turn toward it and move forward
      const goalAngle = furthestGoalAngle;
      const goalDist = furthestGoalDist;
      const absAngle = Math_abs(goalAngle);
      
      // If goal is behind (>90° or <-90°), turn in place first
      if (absAngle > 90) {
        // Turn in place (no forward movement) - goal is behind
        const turnSpeed = clamp(goalAngle / 60, -1, 1) * 0.8; // Slower turn when behind
        const motors = movementToMotors(0, 0, turnSpeed);
        motor1 = motors.motor1;
        motor2 = motors.motor2;
        motor3 = motors.motor3;
        motor4 = motors.motor4;
      } else if (absAngle > 15) {
        // Goal is to the side - turn while moving forward slowly
        const turnSpeed = clamp(goalAngle / 50, -1, 1) * 0.6;
        const forwardSpeed = 0.4; // Moderate forward speed while turning
        const motors = movementToMotors(forwardSpeed, 0, turnSpeed);
        motor1 = motors.motor1;
        motor2 = motors.motor2;
        motor3 = motors.motor3;
        motor4 = motors.motor4;
      } else {
        // Goal is aligned - move straight forward
        const forwardSpeed = 0.7;
        const motors = movementToMotors(forwardSpeed, 0, 0);
        motor1 = motors.motor1;
        motor2 = motors.motor2;
        motor3 = motors.motor3;
        motor4 = motors.motor4;
      }
    } else {
      // Goal not visible - move forward in current direction (should become visible soon with 360 camera)
      const forwardSpeed = 0.6;
      const motors = movementToMotors(forwardSpeed, 0, 0);
      motor1 = motors.motor1;
      motor2 = motors.motor2;
      motor3 = motors.motor3;
      motor4 = motors.motor4;
    }
    
    return { motor1, motor2, motor3, motor4, kick };
  }
  
  // ============================================================
  // STATE: UNCROSSING_LINE (Highest Priority)
  // ============================================================
  if (currentState === STATE.UNCROSSING_LINE) {
    // Ignore all line detection while uncrossing
    ignoreLineDetection = true;
    
    // Set target for display
    currentTarget = null;
    
    // Remove events older than window (event was already recorded when entering this state)
    resetEvents = resetEvents.filter(e => t_ms - e.time < RESET_EVENT_WINDOW_MS);
    
    // Check if we should go to RESET_POSITION
    // CRITICAL: Don't enter RESET_POSITION if ball is visible and close - prioritize attacking!
    // Attackers should only reset when truly stuck, not when they can see the ball
    const ballVisibleAndClose = ball.visible && ball.distance < 80; // Ball within 80cm
    
    // Count event types for debugging
    const stuckCount = resetEvents.filter(e => e.type === 'stuck').length;
    const uncrossingCount = resetEvents.filter(e => e.type === 'uncrossing').length;
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:245',message:'UNCROSSING_LINE reset check',data:{resetEventsLength:resetEvents.length,stuckCount,uncrossingCount,RESET_EVENT_THRESHOLD,ballVisible:ball.visible,ballDist:ball.visible ? ball.distance : null,ballVisibleAndClose,willEnterReset:uncrossingCount >= RESET_EVENT_THRESHOLD},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'Z'})}).catch(()=>{});
    // #endregion
    
    // Enter RESET_POSITION if we have 3+ uncrossing events (regardless of ball visibility)
    // This ensures we reset after multiple line crossings
    if (uncrossingCount >= RESET_EVENT_THRESHOLD) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:242',message:'UNCROSSING_LINE entering RESET_POSITION',data:{resetEventsLength:resetEvents.length,ballVisible:ball.visible,ballDist:ball.visible ? ball.distance : null},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AA'})}).catch(()=>{});
      // #endregion
      currentState = STATE.RESET_POSITION;
      ignoreLineDetection = true;
      resetEvents = []; // Clear events
      resetRotationAccumulated = 0;
      resetLastHeading = null;
      resetDistanceMoved = 0;
      // Set target immediately to furthest goal (never ball) and initialize distance tracking
      if (goal_blue.distance > goal_yellow.distance) {
        resetTargetGoalIsBlue = true;
        currentTarget = 'blue goal';
        resetInitialDistance = goal_blue.distance; // CRITICAL: Set initial distance here
      } else {
        resetTargetGoalIsBlue = false;
        currentTarget = 'yellow goal';
        resetInitialDistance = goal_yellow.distance; // CRITICAL: Set initial distance here
      }
    return { motor1, motor2, motor3, motor4, kick };
  }
  
    // Estimate distance moved based on speed and time
    const BACKOFF_MOTOR_VALUE = 0.6;
    const BACKOFF_SPEED_CM_S = BACKOFF_MOTOR_VALUE * 150; // motor value * max speed
    backoffDistance += BACKOFF_SPEED_CM_S * dt_s;
    
    // Continue reversing until we've moved 10cm
    if (backoffDistance >= BACKOFF_TARGET_CM) {
      // Done reversing - clear line memory and transition back to previous state
      backoffDistance = 0;
      ignoreLineDetection = false;
      lineSensorMemory = {
        front: { active: false, direction: null },
        left: { active: false, direction: null },
        right: { active: false, direction: null },
        rear: { active: false, direction: null }
      };
      // Reset lastLineState to all false - we ignored all line sensors during reverse
      lastLineState = { front: false, left: false, right: false, rear: false };
      
      // Transition back to attacking or searching based on ball visibility
      if (ball.visible) {
        currentState = STATE.ATTACKING;
      } else {
        currentState = STATE.SEARCHING;
      }
    } else {
      // Still reversing - continue moving in opposite direction
      const forwardSpeed = reverseDirection.y * BACKOFF_MOTOR_VALUE;
      const strafeSpeed = reverseDirection.x * BACKOFF_MOTOR_VALUE * 0.7;
      
      // Use omni wheel movement to reverse in the opposite direction
      const motors = movementToMotors(forwardSpeed, strafeSpeed, 0);
      motor1 = motors.motor1;
      motor2 = motors.motor2;
      motor3 = motors.motor3;
      motor4 = motors.motor4;
      
      // CRITICAL: ALL line detection logic is disabled while reversing
    return { motor1, motor2, motor3, motor4, kick };
  }
  }
  
  // ============================================================
  // LINE DETECTION (Check for line crossing - triggers UNCROSSING_LINE state)
  // Skip if line detection is disabled
  // ============================================================
  if (!ignoreLineDetection) {
    // Calculate current movement direction based on ball or goal
    var currentDirection = { x: 0, y: 1 }; // Default: forward
    if (ball.visible) {
      const ballAngleRad = (ball.angle_deg * Math_PI) / 180;
      currentDirection = {
        x: Math_sin(ballAngleRad),
        y: Math_cos(ballAngleRad)
      };
    } else if (targetGoal.visible) {
      const goalAngleRad = (targetGoal.angle_deg * Math_PI) / 180;
      currentDirection = {
        x: Math_sin(goalAngleRad),
        y: Math_cos(goalAngleRad)
      };
    }
    
    // Normalize direction
    const dirLen = Math_sqrt(currentDirection.x * currentDirection.x + currentDirection.y * currentDirection.y);
    if (dirLen > 0.01) {
      currentDirection.x /= dirLen;
      currentDirection.y /= dirLen;
    }
    
    // Check for line sensor transitions and update memory
    const sensors = [
      { name: 'front', value: line_front },
      { name: 'left', value: line_left },
      { name: 'right', value: line_right },
      { name: 'rear', value: line_rear }
    ];
    
    for (const sensor of sensors) {
      const memory = lineSensorMemory[sensor.name];
      const lastValue = lastLineState[sensor.name];
      
      // If sensor just triggered (went from false to true)
      if (sensor.value && !lastValue) {
        // Remember this line detection and the current direction
        memory.active = true;
        memory.direction = { x: currentDirection.x, y: currentDirection.y };
      }
      
      // If sensor is active in memory, check if direction changed by 120+ degrees
      if (memory.active && memory.direction) {
        const rememberedDir = memory.direction;
        const dot = rememberedDir.x * currentDirection.x + rememberedDir.y * currentDirection.y;
        const angleDeg = Math_acos(Math_max(-1, Math_min(1, dot))) * 180 / Math_PI;
        
        // If direction changed by more than 120 degrees, clear memory
        if (angleDeg > 120) {
          memory.active = false;
          memory.direction = null;
        }
      }
      
      // If sensor goes to 0 (off) while still in memory, trigger UNCROSSING_LINE state
      if (!sensor.value && memory.active) {
        // Sensor went off before direction changed - line was crossed
        // Transition directly to UNCROSSING_LINE state
        backoffDistance = 0;
        
        // Determine reverse direction based on which sensor triggered
        if (sensor.name === 'front') {
          reverseDirection = { x: 0, y: -1 }; // Back away
        } else if (sensor.name === 'rear') {
          reverseDirection = { x: 0, y: 1 }; // Move forward
        } else if (sensor.name === 'left') {
          reverseDirection = { x: 1, y: 0 }; // Move right
        } else if (sensor.name === 'right') {
          reverseDirection = { x: -1, y: 0 }; // Move left
        }
        
        // Clear memory for this sensor
        memory.active = false;
        memory.direction = null;
        
        // Transition to UNCROSSING_LINE state
        currentState = STATE.UNCROSSING_LINE;
        
        // Record uncrossing event (only once when entering this state)
        resetEvents.push({ time: t_ms, type: 'uncrossing' });
        // Remove events older than window
        resetEvents = resetEvents.filter(e => t_ms - e.time < RESET_EVENT_WINDOW_MS);
        
        // #region agent log
        const stuckCount = resetEvents.filter(e => e.type === 'stuck').length;
        const uncrossingCount = resetEvents.filter(e => e.type === 'uncrossing').length;
        fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:397',message:'UNCROSSING_LINE event recorded',data:{resetEventsLength:resetEvents.length,stuckCount,uncrossingCount,RESET_EVENT_THRESHOLD},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AD'})}).catch(()=>{});
        // #endregion
        
        // Start reversing immediately
        const BACKOFF_MOTOR_VALUE = 0.6;
        const forwardSpeed = reverseDirection.y * BACKOFF_MOTOR_VALUE;
        const strafeSpeed = reverseDirection.x * BACKOFF_MOTOR_VALUE * 0.7;
        
        // Use omni wheel movement to reverse in the opposite direction
        const motors = movementToMotors(forwardSpeed, strafeSpeed, 0);
        motor1 = motors.motor1;
        motor2 = motors.motor2;
        motor3 = motors.motor3;
        motor4 = motors.motor4;
        
    return { motor1, motor2, motor3, motor4, kick };
  }
    }
    
    // Update last line state
    lastLineState = { front: line_front, left: line_left, right: line_right, rear: line_rear };
  }
  
  // ============================================================
  // STATE: STUCK (Bumper/Wall contact) - Check BEFORE other states
  // ============================================================
  // Check if we're currently in STUCK state
  if (currentState === STATE.STUCK) {
    // Ignore all line detection while stuck
    ignoreLineDetection = true;
    
    // Set target for display
    currentTarget = null;
    
    // Initialize stuck entry time if not set
    if (stuckEntryTime === null) {
      stuckEntryTime = t_ms;
    }
    
    // If no longer stuck AND minimum time has passed, transition back to appropriate state
    const timeInStuck = t_ms - stuckEntryTime;
    const canExit = !stuck && !bumper_front && !bumper_left && !bumper_right && timeInStuck >= MIN_STUCK_TIME_MS;
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:432',message:'STUCK exit check',data:{stuck,bumper_front,bumper_left,bumper_right,ballVisible:ball.visible,timeInStuck,MIN_STUCK_TIME_MS,canExit},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H'})}).catch(()=>{});
    // #endregion
    if (canExit) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:437',message:'STUCK exiting',data:{stuck,bumper_front,bumper_left,bumper_right,ballVisible:ball.visible,timeInStuck,newState:ball.visible ? 'ATTACKING' : 'SEARCHING'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'I'})}).catch(()=>{});
      // #endregion
      stuckEntryTime = null; // Reset stuck entry time
      ignoreLineDetection = false;
      // Transition back based on ball visibility
      if (ball.visible) {
        currentState = STATE.ATTACKING;
      } else {
        currentState = STATE.SEARCHING;
      }
    } else {
      // Still stuck - handle stuck behavior
      if (stuck || bumper_front) {
    drive(-0.5);
        // #region agent log
        fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:506',message:'STUCK driving backward',data:{stuck,bumper_front,motor1,motor2,motor3,motor4},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
        // #endregion
        return { motor1, motor2, motor3, motor4, kick };
      }
      
      if (bumper_left) {
        turn(0.5);
        // #region agent log
        fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:512',message:'STUCK turning right',data:{bumper_left,motor1,motor2,motor3,motor4},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
        // #endregion
        return { motor1, motor2, motor3, motor4, kick };
      }
      
      if (bumper_right) {
        turn(-0.5);
        // #region agent log
        fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:517',message:'STUCK turning left',data:{bumper_right,motor1,motor2,motor3,motor4},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
        // #endregion
        return { motor1, motor2, motor3, motor4, kick };
      }
      
      // If no bumpers but can't exit yet (time constraint), wait in place
      // Don't return zero motors - at least try to turn slightly
      turn(0.1);
      
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:523',message:'STUCK no bumpers, turning',data:{stuck,bumper_front,bumper_left,bumper_right,timeInStuck,motor1,motor2,motor3,motor4},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
      // #endregion
      
    return { motor1, motor2, motor3, motor4, kick };
  }
  }
  
  // Check if we just became stuck (not already in STUCK state)
  // #region agent log
  fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:456',message:'STUCK entry check',data:{currentState,stuck,bumper_front,bumper_left,bumper_right,willEnter:currentState !== STATE.STUCK && (stuck || bumper_front || bumper_left || bumper_right)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'F'})}).catch(()=>{});
  // #endregion
  if (currentState !== STATE.STUCK && (stuck || bumper_front || bumper_left || bumper_right)) {
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:472',message:'Entering STUCK state',data:{stuck,bumper_front,bumper_left,bumper_right,previousState:currentState},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'G'})}).catch(()=>{});
    // #endregion
    currentState = STATE.STUCK;
    stuckEntryTime = t_ms; // Record when we entered STUCK
    ignoreLineDetection = true;
    
    // Record stuck event
    resetEvents.push({ time: t_ms, type: 'stuck' });
    // Remove events older than window
    resetEvents = resetEvents.filter(e => t_ms - e.time < RESET_EVENT_WINDOW_MS);
    
    // Count event types for debugging
    const stuckCount = resetEvents.filter(e => e.type === 'stuck').length;
    const uncrossingCount = resetEvents.filter(e => e.type === 'uncrossing').length;
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:497',message:'STUCK reset check',data:{resetEventsLength:resetEvents.length,stuckCount,uncrossingCount,RESET_EVENT_THRESHOLD,ballVisible:ball.visible,ballDist:ball.visible ? ball.distance : null,willEnterReset:stuckCount >= RESET_EVENT_THRESHOLD},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AB'})}).catch(()=>{});
    // #endregion
    
    // Enter RESET_POSITION if we have 3+ stuck events (regardless of ball visibility)
    // If we're stuck 3+ times, we need to reset to recover, even if ball is visible
    if (stuckCount >= RESET_EVENT_THRESHOLD) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:464',message:'STUCK entering RESET_POSITION',data:{resetEventsLength:resetEvents.length,ballVisible:ball.visible,ballDist:ball.visible ? ball.distance : null},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AC'})}).catch(()=>{});
      // #endregion
      currentState = STATE.RESET_POSITION;
      ignoreLineDetection = true;
      resetEvents = []; // Clear events
      resetRotationAccumulated = 0;
      resetLastHeading = null;
      resetDistanceMoved = 0;
      // Set target immediately to furthest goal (never ball) and initialize distance tracking
      if (goal_blue.distance > goal_yellow.distance) {
        resetTargetGoalIsBlue = true;
        currentTarget = 'blue goal';
        resetInitialDistance = goal_blue.distance; // CRITICAL: Set initial distance here
      } else {
        resetTargetGoalIsBlue = false;
        currentTarget = 'yellow goal';
        resetInitialDistance = goal_yellow.distance; // CRITICAL: Set initial distance here
      }
      return { motor1, motor2, motor3, motor4, kick };
    }
    
    if (stuck || bumper_front) {
      drive(-0.5);
    return { motor1, motor2, motor3, motor4, kick };
  }
  
  if (bumper_left) {
    turn(0.5);
    return { motor1, motor2, motor3, motor4, kick };
  }
  
  if (bumper_right) {
    turn(-0.5);
    return { motor1, motor2, motor3, motor4, kick };
  }
  }
  
  // Ensure line detection is enabled for normal states (unless explicitly disabled above)
  if (currentState !== STATE.UNCROSSING_LINE && currentState !== STATE.STUCK && currentState !== STATE.RESET_POSITION) {
    ignoreLineDetection = false;
  }
  
  // ============================================================
  // GLOBAL CHECK: RESET_POSITION after 3+ uncrossing events
  // ============================================================
  // Check if we should enter RESET_POSITION due to multiple line crossings
  // This check runs in all states (except RESET_POSITION itself) to catch cases where
  // we exited UNCROSSING_LINE before accumulating 3 events
  if (currentState !== STATE.RESET_POSITION && currentState !== STATE.UNCROSSING_LINE && currentState !== STATE.STUCK) {
    // Remove events older than window
    resetEvents = resetEvents.filter(e => t_ms - e.time < RESET_EVENT_WINDOW_MS);
    
    // Count uncrossing events specifically
    const uncrossingCount = resetEvents.filter(e => e.type === 'uncrossing').length;
    
    // If we have 3+ uncrossing events, enter RESET_POSITION (regardless of ball visibility)
    // This ensures we reset after multiple line crossings even if ball is visible
    if (uncrossingCount >= RESET_EVENT_THRESHOLD) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:562',message:'Global check entering RESET_POSITION (3+ uncrossing events)',data:{uncrossingCount,RESET_EVENT_THRESHOLD,currentState,ballVisible:ball.visible,ballDist:ball.visible ? ball.distance : null},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AE'})}).catch(()=>{});
      // #endregion
      currentState = STATE.RESET_POSITION;
      ignoreLineDetection = true;
      resetEvents = []; // Clear events
      resetRotationAccumulated = 0;
      resetLastHeading = null;
      resetDistanceMoved = 0;
      // Set target immediately to furthest goal (never ball) and initialize distance tracking
      if (goal_blue.distance > goal_yellow.distance) {
        resetTargetGoalIsBlue = true;
        currentTarget = 'blue goal';
        resetInitialDistance = goal_blue.distance;
      } else {
        resetTargetGoalIsBlue = false;
        currentTarget = 'yellow goal';
        resetInitialDistance = goal_yellow.distance;
      }
      return { motor1, motor2, motor3, motor4, kick };
    }
  }
  
  // ============================================================
  // STATE: SEARCHING (Look for ball, if not found look for goal)
  // ============================================================
  if (currentState === STATE.SEARCHING) {
    // Set target for display
    if (ball.visible) {
      currentTarget = 'ball';
    } else if (targetGoal.visible) {
      currentTarget = we_are_blue ? 'yellow goal' : 'blue goal';
    } else {
      currentTarget = null;
    }
    
  if (!ball.visible) {
    if (lastBallVisible) {
      searchTime = 0;
    }
    searchTime += dt_s * 1000;
    lastBallVisible = false;
    
      // Search pattern: turn while moving forward to cover more area
    const searchDir = (Math_floor(searchTime / 2000) % 2 === 0) ? 1 : -1;
      const turnSpeed = 0.5 * searchDir;
      const forwardSpeed = 0.4; // Move forward while searching
      
      // Combine turning and forward movement
      const motors = movementToMotors(forwardSpeed, 0, turnSpeed);
      motor1 = motors.motor1;
      motor2 = motors.motor2;
      motor3 = motors.motor3;
      motor4 = motors.motor4;
      
    return { motor1, motor2, motor3, motor4, kick };
    } else {
      // Ball found - transition to ATTACKING
  lastBallVisible = true;
  searchTime = 0;
      currentState = STATE.ATTACKING;
    }
  }
  
  // ============================================================
  // STATE: ATTACKING (Go for ball)
  // ============================================================
  if (currentState === STATE.ATTACKING) {
    // Set target for display
    currentTarget = 'ball';
    
    // If ball lost, transition to SEARCHING
    if (!ball.visible) {
      currentState = STATE.SEARCHING;
      return { motor1, motor2, motor3, motor4, kick };
    }
    
    const ballAngle = ball.angle_deg;
  const ballDist = ball.distance;
  const goalVisible = targetGoal.visible;
  const goalAngle = goalVisible ? targetGoal.angle_deg : 0;
  
  // Check own goal position (CRITICAL: avoid scoring in our own goal!)
  const ownGoalVisible = ownGoal.visible;
  const ownGoalAngle = ownGoalVisible ? ownGoal.angle_deg : 0;
  const alignedWithOwnGoal = ownGoalVisible && Math_abs(ownGoalAngle) < 30;
  const ownGoalInFront = ownGoalVisible && Math_abs(ownGoalAngle) < 60;
  
  // CRITICAL: If we're close to ball and aligned with our own goal, reposition immediately!
  const dangerZone = ballDist < 40 && alignedWithOwnGoal;
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:687',message:'ATTACKING state entry',data:{ballAngle,ballDist,goalVisible,goalAngle,ownGoalVisible,ownGoalAngle,alignedWithOwnGoal,dangerZone},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C,D,E'})}).catch(()=>{});
    // #endregion
  
  // --- CRITICAL: AVOID OWN GOAL - Reposition if aligned with own goal ---
  if (dangerZone) {
    // We're in danger of scoring in our own goal! Reposition immediately
      const turnAway = ownGoalAngle > 0 ? -1 : 1;
    const backSpeed = -0.7;
    const turnSpeed = 0.8 * turnAway;
    
      const motors = movementToMotors(backSpeed, 0, turnSpeed);
      motor1 = motors.motor1;
      motor2 = motors.motor2;
      motor3 = motors.motor3;
      motor4 = motors.motor4;
    
    return { motor1, motor2, motor3, motor4, kick };
  }
  
  // --- APPROACH: Ball is far, turn to face it ---
  if (Math_abs(ballAngle) > 15) {
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:757',message:'ATTACKING TURN PATH',data:{ballAngle,ballDist,ownGoalInFront,alignedWithOwnGoal,condition1:ownGoalInFront && ballDist < 50},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
    // #endregion
    
    // If own goal is in front and we're turning toward it, turn the other way
    if (ownGoalInFront && ballDist < 50) {
      const turnAway = ownGoalAngle > 0 ? -1 : 1;
        const turnSpeed = 0.7 * turnAway;
        // Use turn() function for pure rotation
        turn(turnSpeed);
        
        // #region agent log
        fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:762',message:'ATTACKING turning away from own goal',data:{ballAngle,ballDist,turnAway,turnSpeed,motor1,motor2,motor3,motor4},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'E'})}).catch(()=>{});
        // #endregion
    } else {
      const turnSpeed = clamp(ballAngle / 35, -1, 1) * 0.7;
      // Use turn() function for pure rotation
      turn(turnSpeed);
    
        // Always add forward motion when turning toward ball (unless aligned with own goal)
        if (!alignedWithOwnGoal) {
          // More forward motion when ball is farther away
          const fwd = clamp(ballDist / 150, 0.2, 0.5);
          const fwdMotors = movementToMotors(fwd, 0, 0);
          motor1 += fwdMotors.motor1;
          motor2 += fwdMotors.motor2;
          motor3 += fwdMotors.motor3;
          motor4 += fwdMotors.motor4;
        }
        
        // #region agent log
        fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:777',message:'ATTACKING turning toward ball',data:{ballAngle,ballDist,turnSpeed,forwardMotion:!alignedWithOwnGoal,motor1,motor2,motor3,motor4},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C'})}).catch(()=>{});
        // #endregion
    }
    return { motor1, motor2, motor3, motor4, kick };
  }
  
  // --- APPROACH: Drive toward ball with simple, stable logic ---
  // Simplified approach to reduce oscillation
  if (ballDist > 15) {
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:799',message:'ATTACKING APPROACH PATH',data:{ballAngle,ballDist,alignedWithOwnGoal,ownGoalAngle},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
    // #endregion
    
    // Don't approach if we're aligned with own goal - reposition instead
    if (alignedWithOwnGoal) {
      const turnAway = ownGoalAngle > 0 ? -1 : 1;
      const backSpeed = -0.5;
      const turnSpeed = 0.6 * turnAway;
      
      const motors = movementToMotors(backSpeed, 0, turnSpeed);
      motor1 = motors.motor1;
      motor2 = motors.motor2;
      motor3 = motors.motor3;
      motor4 = motors.motor4;
      
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:808',message:'ATTACKING backing away from own goal',data:{ballAngle,ballDist,backSpeed,turnSpeed,motor1,motor2,motor3,motor4},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
      // #endregion
      
      return { motor1, motor2, motor3, motor4, kick };
    }
    
    // Simple forward movement with small steering correction
    // Reduce steering gain to prevent oscillation
    const speed = clamp(0.4 + ballDist / 300, 0.4, 0.8);
    const steer = clamp(ballAngle / 80, -0.15, 0.15); // Reduced steering gain
    
    // Forward movement with steering correction
    const motors = movementToMotors(speed, 0, steer);
    motor1 = motors.motor1;
    motor2 = motors.motor2;
    motor3 = motors.motor3;
    motor4 = motors.motor4;
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:825',message:'ATTACKING approaching ball',data:{ballAngle,ballDist,speed,steer,vx:speed,vy:0,omega:steer,motor1,motor2,motor3,motor4,allZero:Math_abs(motor1)<0.01&&Math_abs(motor2)<0.01&&Math_abs(motor3)<0.01&&Math_abs(motor4)<0.01},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1,H2,H3'})}).catch(()=>{});
    // #endregion
    
    return { motor1, motor2, motor3, motor4, kick };
  }
  
  // --- CLOSE TO BALL: Push forward and kick ---
  // #region agent log
  fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:836',message:'ATTACKING CLOSE PATH',data:{ballAngle,ballDist,alignedWithOwnGoal,goalVisible,goalAngle},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
  // #endregion
  
  // CRITICAL: Never push/kick if aligned with own goal!
  if (alignedWithOwnGoal) {
    // Turn away from own goal and back up
    const turnAway = ownGoalAngle > 0 ? -1 : 1;
    const backSpeed = -0.5;
    const turnSpeed = 0.6 * turnAway;
    
    const motors = movementToMotors(backSpeed, 0, turnSpeed);
    motor1 = motors.motor1;
    motor2 = motors.motor2;
    motor3 = motors.motor3;
    motor4 = motors.motor4;
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:845',message:'ATTACKING close - backing from own goal',data:{ballDist,ballAngle,backSpeed,turnSpeed,motor1,motor2,motor3,motor4},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1'})}).catch(()=>{});
    // #endregion
    
    return { motor1, motor2, motor3, motor4, kick };
  }
  
  // Push forward with small goal bias (if goal visible)
  const goalBias = goalVisible ? clamp(goalAngle / 80, -0.1, 0.1) : 0; // Reduced bias
  const pushSpeed = 0.7; // Reduced speed to prevent overshooting
  
  // Push forward with goal bias
  const motors = movementToMotors(pushSpeed, 0, goalBias);
  motor1 = motors.motor1;
  motor2 = motors.motor2;
  motor3 = motors.motor3;
  motor4 = motors.motor4;
  
  // #region agent log
  fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:860',message:'ATTACKING pushing ball',data:{ballDist,ballAngle,goalBias,pushSpeed,vx:pushSpeed,vy:0,omega:goalBias,motor1,motor2,motor3,motor4,allZero:Math_abs(motor1)<0.01&&Math_abs(motor2)<0.01&&Math_abs(motor3)<0.01&&Math_abs(motor4)<0.01},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H1,H2,H3'})}).catch(()=>{});
  // #endregion
  
  // Kick when aligned with TARGET goal and close, but NEVER when aligned with own goal
  if (ballDist < 20 && Math_abs(ballAngle) < 8 && !alignedWithOwnGoal) {
    // Double-check: make sure target goal is in front, not own goal
    if (goalVisible && Math_abs(goalAngle) < 45) {
      kick = true;
    } else if (!ownGoalVisible || Math_abs(ownGoalAngle) > 45) {
      // Safe to kick if own goal is not visible or far to the side
      kick = true;
    }
  }
    
    return { motor1, motor2, motor3, motor4, kick };
  }
  
  // #region agent log
  fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'attacker.js:859',message:'ATTACKER final return',data:{currentState,motor1,motor2,motor3,motor4,kick,allZero:motor1===0&&motor2===0&&motor3===0&&motor4===0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C,D,E'})}).catch(()=>{});
  // #endregion
  
  return { motor1, motor2, motor3, motor4, kick };
}

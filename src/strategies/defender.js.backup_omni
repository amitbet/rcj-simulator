// ============================================================
// RoboCup Jr. Simulator - Defender Strategy (State Machine)
// ============================================================
// Motor layout (viewed from above):
//   motor1 (front-left)    motor2 (front-right)
//          [    KICKER    ]  ← FRONT (forward direction)
//   motor4 (back-left)     motor3 (back-right)
//
// Omni wheels at 45-degree angles:
//   - motor1: wheel at 45° (pointing forward-right)
//   - motor2: wheel at -45° (pointing forward-left)
//   - motor3: wheel at 45° (pointing back-left)
//   - motor4: wheel at -45° (pointing back-right)
//
// Forward kinematics (from desired velocity to motor speeds):
//   m1 = (vx + vy) / sqrt(2) + ω
//   m2 = (vx - vy) / sqrt(2) + ω
//   m3 = (-vx - vy) / sqrt(2) + ω
//   m4 = (-vx + vy) / sqrt(2) + ω
//   Where vx = forward/backward, vy = left/right, ω = rotation

// ============================================================
// STATE MACHINE STATES
// ============================================================
const STATE = {
  SEARCHING: 'SEARCHING',
  DEFENDING: 'DEFENDING',
  DEFLECTING: 'DEFLECTING',
  UNCROSSING_LINE: 'UNCROSSING_LINE',
  STUCK: 'STUCK',
  RESET_POSITION: 'RESET_POSITION'
};

// Current state
// TEST MODE: Force DEFENDING state only
var currentState = STATE.DEFENDING;

// Current target (for display)
var currentTarget = null;

// State-specific persistent variables
var searchTime = 0;
var lastBallVisible = true;

// Line detection control
var ignoreLineDetection = false; // Single boolean to ignore all line detection

// Line crossing state
var backoffDistance = 0; // cm moved in reverse direction so far
var reverseDirection = { x: 0, y: 0 }; // Direction to reverse (normalized)
const BACKOFF_TARGET_CM = 10; // Move 10cm in opposite direction before resuming

// Reset position tracking - track stuck/uncrossing events
var resetEvents = []; // Array of { time: number, type: 'stuck' | 'uncrossing' }
const RESET_EVENT_WINDOW_MS = 5000; // 5 seconds window
const RESET_EVENT_THRESHOLD = 3; // Need 3 events within window to trigger reset
var resetTargetGoalIsBlue = null; // true = blue goal, false = yellow goal, null = not set
var resetRotationAccumulated = 0; // Track accumulated rotation during RESET_POSITION (degrees)
var resetLastHeading = null; // Track last heading to calculate rotation
var resetDistanceMoved = 0; // Track distance moved toward target goal during RESET_POSITION (cm)
var resetInitialDistance = null; // Initial distance to goal when entering RESET_POSITION

// Line sensor memory - remember when line was detected and direction
var lineSensorMemory = {
  front: { active: false, direction: null },
  left: { active: false, direction: null },
  right: { active: false, direction: null },
  rear: { active: false, direction: null }
};

// Line sensor trigger tracking - turn to own goal after 3 triggers
var lineTriggerCounts = { front: 0, left: 0, right: 0, rear: 0 };
var lastLineState = { front: false, left: false, right: false, rear: false };
var turningToOwnGoal = false;
var ownGoalTurnComplete = false;
var distanceMovedToGoal = 0; // Track distance moved towards own goal
const GOAL_ADVANCE_DISTANCE_CM = 50; // Move 50cm towards own goal

function strategy(worldState) {
  try {
  const { ball, goal_blue, goal_yellow, we_are_blue, bumper_front, bumper_left, bumper_right,
          line_front, line_left, line_right, line_rear, stuck, t_ms, dt_s } = worldState;
  
  // #region agent log
  fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:73',message:'State check',data:{currentState,validState:Object.values(STATE).includes(currentState),lineFront:line_front,lineLeft:line_left,lineRight:line_right,lineRear:line_rear,ignoreLineDetection,stuck,bumper_front,bumper_left,bumper_right},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AF'})}).catch(()=>{});
  // #endregion
  
  // Our goal (the one we defend)
  const ownGoal = we_are_blue ? goal_blue : goal_yellow;
  // Opponent goal (where we want to push the ball)
  const opponentGoal = we_are_blue ? goal_yellow : goal_blue;
  
  let motor1 = 0, motor2 = 0, motor3 = 0, motor4 = 0;
  let kick = false;
  
  // Defense zone - stay within 40cm of own goal (half circle)
  const MAX_DISTANCE_FROM_GOAL = 40;
  // Deflecting zone - can go up to 100cm from own goal (edge of half-field)
  const MAX_DEFLECTING_DISTANCE = 100;
  
  // Helper: clamp value
  function clamp(val, min, max) {
    return Math_max(min, Math_min(max, val));
  }
  
  // Helper: Convert desired movement to differential drive motor speeds
  // REVERTED: Using differential drive interpretation that worked for rectangle/diamond/rotation tests
  // vx = forward/backward (forward = +), omega = rotation (CW = +, CCW = -)
  // For differential drive: leftSide = vx - omega, rightSide = vx + omega
  // Motor mapping: m1,m4 = leftSide, m2,m3 = rightSide
  function movementToMotors(vx, vy, omega) {
    // For differential drive, vy (strafe) is not directly supported
    // Convert vy to a rotation component: strafe right = turn right while moving forward
    const leftSide = vx - omega + (vy * 0.3);  // Add small turn component for strafe
    const rightSide = vx + omega - (vy * 0.3);
    
    return {
      motor1: clamp(leftSide, -1, 1),   // left front
      motor2: clamp(rightSide, -1, 1),   // right front
      motor3: clamp(rightSide, -1, 1),   // right back
      motor4: clamp(leftSide, -1, 1)     // left back
    };
  }
  
  // Helper: turn in place (positive = turn right/CW)
  // REVERTED: Using differential drive pattern that worked for rotation tests
  // CW: leftSide negative, rightSide positive (leftSide < rightSide)
  // CCW: leftSide positive, rightSide negative (leftSide > rightSide)
  function turn(speed) {
    if (speed > 0) {
      // Rotate CW: leftSide negative, rightSide positive
      motor1 = -speed;  // left front
      motor4 = -speed;  // left back
      motor2 = speed;   // right front
      motor3 = speed;   // right back
    } else if (speed < 0) {
      // Rotate CCW: leftSide positive, rightSide negative
      motor1 = -speed;  // left front (positive)
      motor4 = -speed;  // left back (positive)
      motor2 = speed;   // right front (negative)
      motor3 = speed;   // right back (negative)
    } else {
      // No rotation
      motor1 = 0;
      motor2 = 0;
      motor3 = 0;
      motor4 = 0;
    }
  }
  
  // Helper: Strafe at any angle while maintaining forward orientation
  // angle_deg: angle in degrees (0 = forward, 90 = right, -90 = left, 180 = backward)
  // speed: movement speed (0..1)
  // omega: optional rotation speed (default 0 to maintain orientation)
  // Returns motor speeds for strafing at the specified angle
  function strafeAtAngle(angle_deg, speed, omega = 0) {
    // Convert angle to radians
    const angle_rad = angle_deg * Math_PI / 180;
    // Calculate vx (forward/backward) and vy (left/right) components
    const vx = speed * Math_cos(angle_rad); // Forward component
    const vy = speed * Math_sin(angle_rad); // Right component (positive = right)
    return movementToMotors(vx, vy, omega);
  }
  
  // Helper: return action with state and target
  function returnAction() {
    // Ensure state is always valid - default to DEFENDING if invalid
    let validState = currentState;
    if (!validState || !Object.values(STATE).includes(validState)) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:100',message:'Invalid state in returnAction, defaulting to DEFENDING',data:{invalidState:currentState,validStates:Object.values(STATE)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AK'})}).catch(()=>{});
      // #endregion
      validState = STATE.DEFENDING;
      currentState = STATE.DEFENDING; // Also update the global state
    }
    
    const result = { motor1, motor2, motor3, motor4, kick };
    result._state = validState;
    result._target = currentTarget;
    return result;
  }
  
  // ============================================================
  // STATE: RESET_POSITION (Ignore all lines, navigate to furthest goal)
  // TEST MODE: DISABLED - Only DEFENDING allowed
  // ============================================================
  if (false && currentState === STATE.RESET_POSITION) {
    // Ignore all line detection
    ignoreLineDetection = true;
    
    // Lock onto the furthest goal when first entering this state
    // This helps defenders get unstuck by moving away from their own goal area
    if (resetTargetGoalIsBlue === null) {
      // Find the goal that is furthest from the robot's current position
      // Compare distances (always calculated, even if not visible)
      if (goal_blue.distance > goal_yellow.distance) {
        resetTargetGoalIsBlue = true;
        currentTarget = 'blue goal';
        resetInitialDistance = goal_blue.distance;
      } else {
        resetTargetGoalIsBlue = false;
        currentTarget = 'yellow goal';
        resetInitialDistance = goal_yellow.distance;
      }
      // Reset rotation tracking (not needed for omni but kept for compatibility)
      resetRotationAccumulated = 0;
      resetLastHeading = null;
      resetDistanceMoved = 0; // Reset distance tracking
      
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:127',message:'RESET_POSITION initialized (furthest goal)',data:{resetTargetGoalIsBlue,resetInitialDistance,goalBlueDist:goal_blue.distance,goalYellowDist:goal_yellow.distance,we_are_blue,ownGoalDist:ownGoal.distance},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'BS'})}).catch(()=>{});
      // #endregion
    }
    
    // Always set target to goal (never ball) in RESET_POSITION
    currentTarget = resetTargetGoalIsBlue ? 'blue goal' : 'yellow goal';
    
    // Get fresh distance from current goal observations (they update each frame)
    const furthestGoalDist = resetTargetGoalIsBlue ? goal_blue.distance : goal_yellow.distance;
    const furthestGoalVis = resetTargetGoalIsBlue ? goal_blue.visible : goal_yellow.visible;
    const furthestGoalAngle = resetTargetGoalIsBlue ? goal_blue.angle_deg : goal_yellow.angle_deg;
    
    // Determine if target goal is opponent's goal
    const isOpponentGoal = resetTargetGoalIsBlue !== we_are_blue;
    // Limit movement: 30cm if opponent goal, 60cm if own goal
    const maxResetDistance = isOpponentGoal ? 30 : 60;
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:155',message:'RESET_POSITION active (furthest goal)',data:{furthestGoalDist,furthestGoalVis,resetInitialDistance,resetDistanceMoved,resetTargetGoalIsBlue,isOpponentGoal,maxResetDistance,we_are_blue},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'BT'})}).catch(()=>{});
    // #endregion
    
    // Calculate distance moved toward goal (difference from initial distance)
    // Only update if goal is visible - if not visible, keep last known value
    if (resetInitialDistance !== null && furthestGoalVis) {
      resetDistanceMoved = resetInitialDistance - furthestGoalDist;
      // Ensure distance moved is non-negative (we're moving toward goal, not away)
      if (resetDistanceMoved < 0) {
        resetDistanceMoved = 0; // Reset if we somehow moved away
      }
    }
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:173',message:'RESET_POSITION distance tracking (toward furthest goal)',data:{resetInitialDistance,furthestGoalDist,resetDistanceMoved,furthestGoalVis,resetTargetGoalIsBlue,isOpponentGoal,maxResetDistance,exitCondition:resetDistanceMoved >= maxResetDistance},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'BX'})}).catch(()=>{});
    // #endregion
    
    // Exit reset after moving the appropriate distance toward the target goal
    // If targeting opponent goal, limit to 30cm; if own goal, allow 60cm
    // CRITICAL: Only exit RESET_POSITION when minimum distance has been moved
    // This ensures RESET_POSITION completes before allowing transitions to other states
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:181',message:'RESET_POSITION exit check',data:{resetDistanceMoved,furthestGoalDist,furthestGoalVis,isOpponentGoal,maxResetDistance,checkExit:resetDistanceMoved >= maxResetDistance,willExit:resetDistanceMoved >= maxResetDistance},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'BY'})}).catch(()=>{});
    // #endregion
    
    if (resetDistanceMoved >= maxResetDistance) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:186',message:'RESET_POSITION exiting - distance requirement met',data:{resetDistanceMoved,furthestGoalDist,furthestGoalVis,isOpponentGoal,maxResetDistance,exitReason:`moved${maxResetDistance}cm`},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'BZ'})}).catch(()=>{});
      // #endregion
      ignoreLineDetection = false;
      resetEvents = []; // Clear reset events
      resetTargetGoalIsBlue = null; // Clear locked goal
      resetRotationAccumulated = 0;
      resetLastHeading = null;
      resetDistanceMoved = 0;
      resetInitialDistance = null;
      // Transition to DEFENDING state (defender preference)
      currentState = STATE.DEFENDING;
      return returnAction();
    }
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:203',message:'RESET_POSITION continuing - distance not yet met',data:{resetDistanceMoved,maxResetDistance,remaining:maxResetDistance - resetDistanceMoved},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'CA'})}).catch(()=>{});
    // #endregion
    
    // Move toward goal using differential drive (turn + forward)
    // Physics engine uses differential drive, not true omnidirectional
    if (furthestGoalVis) {
      // Goal is visible - turn toward it and move forward
      const goalAngle = furthestGoalAngle;
      const goalDist = furthestGoalDist;
      const absAngle = Math_abs(goalAngle);
      
      // If goal is behind (>90° or <-90°), turn in place first
      if (absAngle > 90) {
        // Turn in place (no forward movement) - goal is behind
        const turnSpeed = clamp(goalAngle / 60, -1, 1) * 0.8; // Slower turn when behind
        
        motor1 = -turnSpeed; // Left side
        motor4 = -turnSpeed;
        motor2 = turnSpeed; // Right side
        motor3 = turnSpeed;
      } else if (absAngle > 15) {
        // Goal is to the side - turn while moving forward slowly
        const turnSpeed = clamp(goalAngle / 50, -1, 1) * 0.6;
        const forwardSpeed = 0.4; // Moderate forward speed while turning
        
        motor1 = forwardSpeed - turnSpeed; // Left side
        motor4 = forwardSpeed - turnSpeed;
        motor2 = forwardSpeed + turnSpeed; // Right side
        motor3 = forwardSpeed + turnSpeed;
      } else {
        // Goal is aligned - move straight forward
        const forwardSpeed = 0.7;
        motor1 = forwardSpeed;
        motor2 = forwardSpeed;
        motor3 = forwardSpeed;
        motor4 = forwardSpeed;
      }
    } else {
      // Goal not visible - move forward in current direction (should become visible soon with 360 camera)
      const forwardSpeed = 0.6;
      motor1 = forwardSpeed;
      motor2 = forwardSpeed;
      motor3 = forwardSpeed;
      motor4 = forwardSpeed;
    }
    
    return returnAction();
  }
  
  // ============================================================
  // STATE: UNCROSSING_LINE (Highest Priority)
  // TEST MODE: DISABLED - Only DEFENDING allowed
  // ============================================================
  if (false && currentState === STATE.UNCROSSING_LINE) {
    // Ignore all line detection while uncrossing
    ignoreLineDetection = true;
    
    // Set target for display
    currentTarget = null;
    
    // Remove events older than window (event was already recorded when entering this state)
    resetEvents = resetEvents.filter(e => t_ms - e.time < RESET_EVENT_WINDOW_MS);
    
    // Check if we should go to RESET_POSITION
    if (resetEvents.length >= RESET_EVENT_THRESHOLD) {
      // TEST MODE: Disabled - stay in DEFENDING
      // currentState = STATE.RESET_POSITION;
      ignoreLineDetection = true;
      resetEvents = []; // Clear events
      resetRotationAccumulated = 0;
      resetLastHeading = null;
      resetDistanceMoved = 0;
      // Find the furthest goal (same logic as RESET_POSITION initialization)
      if (goal_blue.distance > goal_yellow.distance) {
        resetTargetGoalIsBlue = true;
        currentTarget = 'blue goal';
        resetInitialDistance = goal_blue.distance;
      } else {
        resetTargetGoalIsBlue = false;
        currentTarget = 'yellow goal';
        resetInitialDistance = goal_yellow.distance;
      }
      return returnAction();
    }
    
    // Safety check: ensure reverseDirection is set (should be set when entering this state)
    if (!reverseDirection || (reverseDirection.x === 0 && reverseDirection.y === 0)) {
      // Default to backing up if direction not set
      reverseDirection = { x: 0, y: -1 }; // Back away
      backoffDistance = 0; // Reset since we're starting fresh
    }
    
    // Estimate distance moved based on speed and time
    const BACKOFF_MOTOR_VALUE = 0.6;
    const BACKOFF_SPEED_CM_S = BACKOFF_MOTOR_VALUE * 150; // motor value * max speed
    backoffDistance += BACKOFF_SPEED_CM_S * dt_s;
    
    // Continue reversing until we've moved 10cm
    if (backoffDistance >= BACKOFF_TARGET_CM) {
      // Done reversing - clear line memory and transition back to previous state
      backoffDistance = 0;
      reverseDirection = { x: 0, y: 0 }; // Reset direction
      ignoreLineDetection = false;
      lineSensorMemory = {
        front: { active: false, direction: null },
        left: { active: false, direction: null },
        right: { active: false, direction: null },
        rear: { active: false, direction: null }
      };
      // Reset lastLineState to all false - we ignored all line sensors during reverse
      lastLineState = { front: false, left: false, right: false, rear: false };
      
      // Transition back to defending or searching based on ball visibility
      if (ball.visible) {
        // TEST MODE: Always stay in DEFENDING
        currentState = STATE.DEFENDING;
      } else {
        // TEST MODE: Always stay in DEFENDING
        currentState = STATE.DEFENDING;
      }
    } else {
      // Still reversing - continue moving in opposite direction
      const forwardSpeed = reverseDirection.y * BACKOFF_MOTOR_VALUE;
      const strafeSpeed = reverseDirection.x * BACKOFF_MOTOR_VALUE * 0.7;
      
      // Reset motors first
      motor1 = 0;
      motor2 = 0;
      motor3 = 0;
      motor4 = 0;
      
      // Apply strafe (sideways) movement if needed
      if (Math_abs(strafeSpeed) > 0.1) {
        motor1 = strafeSpeed;
        motor2 = -strafeSpeed;
        motor3 = strafeSpeed;
        motor4 = -strafeSpeed;
      }
      // Apply forward/backward movement if needed
      if (Math_abs(forwardSpeed) > 0.1) {
        motor1 += forwardSpeed;
        motor2 += forwardSpeed;
        motor3 += forwardSpeed;
        motor4 += forwardSpeed;
      }
      
      // CRITICAL: ALL line detection logic is disabled while reversing
    return returnAction();
  }
  }
  
  // ============================================================
  // LINE DETECTION (Check for line crossing - triggers UNCROSSING_LINE state)
  // Skip if line detection is disabled
  // ============================================================
  if (!ignoreLineDetection) {
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:377',message:'Line detection check',data:{currentState,ignoreLineDetection,lineFront:line_front,lineLeft:line_left,lineRight:line_right,lineRear:line_rear},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AM'})}).catch(()=>{});
    // #endregion
    // Calculate current movement direction based on ball or goal
    var currentDirection = { x: 0, y: 1 }; // Default: forward
    if (ball.visible) {
      const ballAngleRad = (ball.angle_deg * Math_PI) / 180;
      currentDirection = {
        x: Math_sin(ballAngleRad),
        y: Math_cos(ballAngleRad)
      };
    } else if (ownGoal.visible) {
      const goalAngleRad = (ownGoal.angle_deg * Math_PI) / 180;
      currentDirection = {
        x: Math_sin(goalAngleRad),
        y: Math_cos(goalAngleRad)
      };
    }
    
    // Normalize direction
    const dirLen = Math_sqrt(currentDirection.x * currentDirection.x + currentDirection.y * currentDirection.y);
    if (dirLen > 0.01) {
      currentDirection.x /= dirLen;
      currentDirection.y /= dirLen;
    }
    
    // Check for line sensor transitions and update memory
    const sensors = [
      { name: 'front', value: line_front },
      { name: 'left', value: line_left },
      { name: 'right', value: line_right },
      { name: 'rear', value: line_rear }
    ];
    
    for (const sensor of sensors) {
      const memory = lineSensorMemory[sensor.name];
      const lastValue = lastLineState[sensor.name];
      
      // If sensor just triggered (went from false to true)
      if (sensor.value && !lastValue) {
        memory.active = true;
        memory.direction = { x: currentDirection.x, y: currentDirection.y };
      }
      
      // If sensor is active in memory, check if direction changed by 120+ degrees
      if (memory.active && memory.direction) {
        const rememberedDir = memory.direction;
        const dot = rememberedDir.x * currentDirection.x + rememberedDir.y * currentDirection.y;
        const angleDeg = Math_acos(Math_max(-1, Math_min(1, dot))) * 180 / Math_PI;
        
        if (angleDeg > 120) {
          memory.active = false;
          memory.direction = null;
        }
      }
      
      // If sensor goes to 0 (off) while still in memory, trigger UNCROSSING_LINE state
      if (!sensor.value && memory.active) {
        // Sensor went off before direction changed - line was crossed
        // Transition directly to UNCROSSING_LINE state
        backoffDistance = 0;
        
        // Determine reverse direction based on which sensor triggered
        if (sensor.name === 'front') {
          reverseDirection = { x: 0, y: -1 }; // Back away
        } else if (sensor.name === 'rear') {
          // For defenders near goal, move sideways instead of forward
          const veryCloseToGoal = ownGoal.visible && ownGoal.distance < 30;
          if (veryCloseToGoal) {
            const goalSide = ownGoal.visible && ownGoal.angle_deg !== undefined ? 
                           (ownGoal.angle_deg > 0 ? 1 : -1) : 1;
            reverseDirection = { x: goalSide, y: 0 }; // Move sideways
          } else {
            reverseDirection = { x: 0, y: 1 }; // Move forward
          }
        } else if (sensor.name === 'left') {
          reverseDirection = { x: 1, y: 0 }; // Move right
        } else if (sensor.name === 'right') {
          reverseDirection = { x: -1, y: 0 }; // Move left
        }
        
        // Clear memory for this sensor
        memory.active = false;
        memory.direction = null;
        
        // Transition to UNCROSSING_LINE state
        const previousState = currentState;
        // TEST MODE: Disabled - stay in DEFENDING
        // currentState = STATE.UNCROSSING_LINE;
        
        // #region agent log
        fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:441',message:'Line detected, transitioning to UNCROSSING_LINE',data:{sensorName:sensor.name,previousState,newState:currentState,reverseDirection,ignoreLineDetection},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AH'})}).catch(()=>{});
        // #endregion
        
        // Record uncrossing event (only once when entering this state)
        resetEvents.push({ time: t_ms, type: 'uncrossing' });
        // Remove events older than window
        resetEvents = resetEvents.filter(e => t_ms - e.time < RESET_EVENT_WINDOW_MS);
        
        // Start reversing immediately
        const BACKOFF_MOTOR_VALUE = 0.6;
        const forwardSpeed = reverseDirection.y * BACKOFF_MOTOR_VALUE;
        const strafeSpeed = reverseDirection.x * BACKOFF_MOTOR_VALUE * 0.7;
        
        if (Math_abs(strafeSpeed) > 0.1) {
          motor1 = strafeSpeed;
          motor2 = -strafeSpeed;
          motor3 = strafeSpeed;
          motor4 = -strafeSpeed;
        }
        if (Math_abs(forwardSpeed) > 0.1) {
          motor1 += forwardSpeed;
          motor2 += forwardSpeed;
          motor3 += forwardSpeed;
          motor4 += forwardSpeed;
        }
        
        return returnAction();
      }
    }
    
    // Update last line state
    lastLineState = { front: line_front, left: line_left, right: line_right, rear: line_rear };
  }
  
  // ============================================================
  // STATE: STUCK (Bumper/Wall contact) - Check BEFORE other states
  // TEST MODE: DISABLED - Only DEFENDING allowed
  // ============================================================
  // Check if we're currently in STUCK state
  if (false && currentState === STATE.STUCK) {
    // Ignore all line detection while stuck
    ignoreLineDetection = true;
    
    // Set target for display
    currentTarget = null;
    
    // If no longer stuck, transition back to appropriate state
    if (!stuck && !bumper_front && !bumper_left && !bumper_right) {
      ignoreLineDetection = false;
      // Transition back based on ball visibility
      if (ball.visible) {
        // TEST MODE: Always stay in DEFENDING
        currentState = STATE.DEFENDING;
      } else {
        // TEST MODE: Always stay in DEFENDING
        currentState = STATE.DEFENDING;
      }
    } else {
      // Still stuck - handle stuck behavior
      if (stuck || bumper_front) {
        motor1 = -0.6;
        motor2 = -0.6;
        motor3 = -0.6;
        motor4 = -0.6;
        return returnAction();
      }
      
      if (bumper_left) {
        motor1 = -0.3;
        motor2 = 0.3;
        motor3 = 0.3;
        motor4 = -0.3;
        return returnAction();
      }
      
      if (bumper_right) {
        motor1 = 0.3;
        motor2 = -0.3;
        motor3 = -0.3;
        motor4 = 0.3;
    return returnAction();
      }
    }
  }
  
  // Check if we just became stuck (not already in STUCK state)
  // TEST MODE: Disabled - stay in DEFENDING
  if (false && currentState !== STATE.STUCK && (stuck || bumper_front || bumper_left || bumper_right)) {
    // currentState = STATE.STUCK;
    ignoreLineDetection = true;
    
    // Record stuck event
    resetEvents.push({ time: t_ms, type: 'stuck' });
    // Remove events older than window
    resetEvents = resetEvents.filter(e => t_ms - e.time < RESET_EVENT_WINDOW_MS);
    
    // Check if we should go to RESET_POSITION
    if (resetEvents.length >= RESET_EVENT_THRESHOLD) {
      // TEST MODE: Disabled - stay in DEFENDING
      // currentState = STATE.RESET_POSITION;
      ignoreLineDetection = true;
      resetEvents = []; // Clear events
      resetRotationAccumulated = 0;
      resetLastHeading = null;
      resetDistanceMoved = 0;
      // Find the furthest goal (same logic as RESET_POSITION initialization)
      if (goal_blue.distance > goal_yellow.distance) {
        resetTargetGoalIsBlue = true;
        currentTarget = 'blue goal';
        resetInitialDistance = goal_blue.distance;
      } else {
        resetTargetGoalIsBlue = false;
        currentTarget = 'yellow goal';
        resetInitialDistance = goal_yellow.distance;
      }
      return returnAction();
    }
    
  if (stuck || bumper_front) {
    motor1 = -0.6;
    motor2 = -0.6;
    motor3 = -0.6;
    motor4 = -0.6;
    return returnAction();
  }
  
  if (bumper_left) {
    motor1 = -0.3;
    motor2 = 0.3;
    motor3 = 0.3;
    motor4 = -0.3;
    return returnAction();
  }
  
  if (bumper_right) {
    motor1 = 0.3;
    motor2 = -0.3;
    motor3 = -0.3;
    motor4 = 0.3;
    return returnAction();
    }
  }
  
  // Ensure line detection is enabled for normal states (unless explicitly disabled above)
  // This check happens AFTER line detection, so it doesn't affect the current frame's line detection
  // But it ensures line detection is enabled for the next frame
  if (currentState !== STATE.UNCROSSING_LINE && currentState !== STATE.STUCK && currentState !== STATE.RESET_POSITION) {
    ignoreLineDetection = false;
    // #region agent log
    if (currentState === STATE.DEFENDING || currentState === STATE.DEFLECTING) {
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:597',message:'Line detection enabled for next frame',data:{currentState,ignoreLineDetection},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AP'})}).catch(()=>{});
    }
    // #endregion
  }
  
  // ============================================================
  // STATE: SEARCHING (Look for own goal, then priority2 = ball)
  // TEST MODE: DISABLED - Only DEFENDING allowed
  // ============================================================
  if (false && currentState === STATE.SEARCHING) {
    // Set target for display
    if (ball.visible) {
      currentTarget = 'ball';
    } else if (ownGoal.visible) {
      currentTarget = we_are_blue ? 'blue goal' : 'yellow goal';
    } else {
      currentTarget = null;
    }
    
  if (!ball.visible) {
    if (lastBallVisible) {
      searchTime = 0;
    }
    searchTime += dt_s * 1000;
    lastBallVisible = false;
    
      // If too far from goal, move back
    if (ownGoal.visible && ownGoal.distance > MAX_DISTANCE_FROM_GOAL) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:545',message:'SEARCHING too far from goal, backing up',data:{distanceFromGoal:ownGoal.distance,MAX_DISTANCE_FROM_GOAL},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'H'})}).catch(()=>{});
      // #endregion
      if (Math_abs(ownGoal.angle_deg) > 25) {
        const turn = clamp(ownGoal.angle_deg / 50, -1, 1) * 0.5;
        motor1 = -turn - 0.5; // Back up while turning
        motor4 = -turn - 0.5;
        motor2 = turn - 0.5;
        motor3 = turn - 0.5;
      } else {
        motor1 = -0.6; // Back up straight
        motor2 = -0.6;
        motor3 = -0.6;
        motor4 = -0.6;
      }
    } else {
        // Search for ball: turn in place or move backward slightly, never forward
      const searchDirection = (Math_floor(searchTime / 1500) % 2 === 0) ? 1 : -1;
        const turnSpeed = 0.4 * searchDirection;
        const backSpeed = -0.1; // Small backward movement to stay within bounds
        
        motor1 = backSpeed - turnSpeed;
        motor4 = backSpeed - turnSpeed;
        motor2 = backSpeed + turnSpeed;
        motor3 = backSpeed + turnSpeed;
    }
      return returnAction();
    } else {
      // Ball found - transition to DEFENDING
      lastBallVisible = true;
      searchTime = 0;
      currentState = STATE.DEFENDING;
    }
  }
  
  // ============================================================
  // STATE: DEFENDING (Track own goal, stay within 50cm, track ball within bounds)
  // ============================================================
  // Defensive check: Don't allow DEFENDING if RESET_POSITION is active and not complete
  // TEST MODE: Disabled - always allow DEFENDING
  if (false && currentState === STATE.RESET_POSITION) {
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:651',message:'DEFENDING blocked - RESET_POSITION still active',data:{resetDistanceMoved},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'BG'})}).catch(()=>{});
    // #endregion
    // RESET_POSITION should have been handled earlier, but if we somehow reach here, 
    // don't allow DEFENDING to execute - RESET_POSITION must complete first
    return returnAction();
  }
  
  if (currentState === STATE.DEFENDING) {
    // Set target for display
    if (ball.visible) {
      currentTarget = 'ball';
    } else if (ownGoal.visible) {
      currentTarget = we_are_blue ? 'blue goal' : 'yellow goal';
    } else {
      currentTarget = null;
    }
    
    const distanceFromGoal = ownGoal.visible ? ownGoal.distance : 999;
    
    // Check if ball is close - transition to DEFLECTING if ball is within 40cm
    // TEST MODE: DISABLED - Stay in DEFENDING
    if (false && ball.visible && ball.distance < 40) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:647',message:'DEFENDING transitioning to DEFLECTING (ball close)',data:{ballDist:ball.distance,distanceFromGoal},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'M'})}).catch(()=>{});
      // #endregion
      // TEST MODE: Disabled - stay in DEFENDING
      // currentState = STATE.DEFLECTING;
      return returnAction();
    }
    
    // DEFENDING: Stay within 40cm half circle around own goal, orient towards ball to block it
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:704',message:'DEFENDING state check',data:{distanceFromGoal,MAX_DISTANCE_FROM_GOAL,ballVisible:ball.visible,ownGoalVisible:ownGoal.visible,ballDist:ball.visible ? ball.distance : null,willDoArcPositioning:distanceFromGoal <= MAX_DISTANCE_FROM_GOAL && ball.visible && ownGoal.visible},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'CF'})}).catch(()=>{});
    // #endregion
    
    // If too far from goal (>60cm), move toward it (not backward, but toward the goal)
    // Use 60cm threshold to allow arc positioning to activate when closer
    if (distanceFromGoal > 60) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:712',message:'DEFENDING too far from goal (>60cm), moving toward goal',data:{distanceFromGoal,MAX_DISTANCE_FROM_GOAL,ownGoalVisible:ownGoal.visible,goalAngle:ownGoal.visible ? ownGoal.angle_deg : null,lineFront:line_front,lineLeft:line_left,lineRight:line_right,lineRear:line_rear},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'CM'})}).catch(()=>{});
      // #endregion
      // Too far from goal - move toward it (forward if goal is in front, backward if goal is behind)
      if (ownGoal.visible) {
        const goalAngle = ownGoal.angle_deg;
        const absGoalAngle = Math_abs(goalAngle);
        
        if (absGoalAngle > 90) {
          // Goal is behind us - turn toward goal while moving forward to reposition
          // This helps us get into a better position relative to the goal
          const turnSpeed = clamp(goalAngle / 60, -1, 1) * 0.6;
          const forwardSpeed = 0.3; // Move forward to reposition
          motor1 = forwardSpeed - turnSpeed;
          motor4 = forwardSpeed - turnSpeed;
          motor2 = forwardSpeed + turnSpeed;
          motor3 = forwardSpeed + turnSpeed;
        } else if (absGoalAngle > 20) {
          // Goal is to the side - turn toward goal while moving forward
          const turn = clamp(goalAngle / 40, -1, 1) * 0.6;
          const forwardSpeed = 0.5; // Move forward toward goal
          motor1 = forwardSpeed - turn;
          motor4 = forwardSpeed - turn;
          motor2 = forwardSpeed + turn;
          motor3 = forwardSpeed + turn;
        } else {
          // Facing goal - move forward straight toward it
          const forwardSpeed = 0.6;
          motor1 = forwardSpeed;
          motor2 = forwardSpeed;
          motor3 = forwardSpeed;
          motor4 = forwardSpeed;
        }
      } else {
        // Goal not visible - turn and search
        const turnSpeed = 0.4;
        motor1 = -turnSpeed;
        motor4 = -turnSpeed;
        motor2 = turnSpeed;
        motor3 = turnSpeed;
      }
      return returnAction();
    }
    
    // Within reasonable bounds (<=60cm) - strafe left/right along goal while facing opponent
    // Allow arc positioning when within 60cm so defender can reach the arc
    if (ball.visible && ownGoal.visible && distanceFromGoal <= 60) {
  const ballAngle = ball.angle_deg;
  const ballDist = ball.distance;
      const goalAngle = ownGoal.angle_deg;
      const opponentGoalAngle = opponentGoal.visible ? opponentGoal.angle_deg : null;
      
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:757',message:'DEFENDING strafe along goal',data:{ballAngle,ballDist,distanceFromGoal,goalAngle,opponentGoalAngle,opponentGoalVisible:opponentGoal.visible},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'CP'})}).catch(()=>{});
      // #endregion
      
      const desiredDistance = MAX_DISTANCE_FROM_GOAL; // Stay on the arc (40cm from goal)
      const distanceError = distanceFromGoal - desiredDistance;
      
      // Calculate angle from goal to ball to determine strafe direction
      let goalToBallAngle = ballAngle - goalAngle;
      // Normalize angle to -180..180
      while (goalToBallAngle > 180) goalToBallAngle -= 360;
      while (goalToBallAngle < -180) goalToBallAngle += 360;
      
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:806',message:'DEFENDING calculating angles',data:{ballAngle,goalAngle,goalToBallAngle,distanceFromGoal,desiredDistance:MAX_DISTANCE_FROM_GOAL,distanceError},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C'})}).catch(()=>{});
      // #endregion
      
      // Strafe direction: positive = right, negative = left
      // If ball is to the right of goal, strafe right; if left, strafe left
      const strafeSpeed = clamp(Math_abs(goalToBallAngle) / 90, 0, 1) * 0.4;
      const strafeDirection = goalToBallAngle > 0 ? 1 : -1; // Positive = right, negative = left
      
      // Turn to face opponent goal (if visible)
      let turnToOpponent = 0;
      if (opponentGoal.visible && opponentGoalAngle !== null) {
        turnToOpponent = clamp(opponentGoalAngle / 50, -1, 1) * 0.6;
      }
      
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:775',message:'DEFENDING strafe calculation',data:{goalToBallAngle,strafeSpeed,strafeDirection,turnToOpponent,distanceError,absDistanceError:Math_abs(distanceError),distanceFromGoal,desiredDistance},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'CQ'})}).catch(()=>{});
      // #endregion
      
      // Adjust distance if needed
      if (Math_abs(distanceError) > 10) {
        // Need to adjust distance - move toward or away from goal
        if (distanceError > 0) {
          // Too far - move back toward goal
          if (Math_abs(goalAngle) > 90) {
            // Goal is behind - turn toward goal while moving forward
            const turnSpeed = clamp(goalAngle / 60, -1, 1) * 0.6;
            const forwardSpeed = 0.3;
            const motors = movementToMotors(forwardSpeed, 0, turnSpeed);
            motor1 = motors.motor1;
            motor2 = motors.motor2;
            motor3 = motors.motor3;
            motor4 = motors.motor4;
          } else if (Math_abs(goalAngle) > 15) {
            // Goal is to the side - turn toward goal while moving forward
            const turn = clamp(goalAngle / 40, -1, 1) * 0.5;
            const forwardSpeed = 0.4;
            const motors = movementToMotors(forwardSpeed, 0, turn);
            motor1 = motors.motor1;
            motor2 = motors.motor2;
            motor3 = motors.motor3;
            motor4 = motors.motor4;
    } else {
            // Facing goal - move forward straight
            const forwardSpeed = 0.5;
            const motors = movementToMotors(forwardSpeed, 0, 0);
            motor1 = motors.motor1;
            motor2 = motors.motor2;
            motor3 = motors.motor3;
            motor4 = motors.motor4;
          }
        } else {
          // Too close - move away from goal
          const forwardSpeed = 0.3;
          if (Math_abs(goalAngle) > 15) {
            // Turn away from goal while moving forward
            const turn = clamp(-goalAngle / 40, -1, 1) * 0.5;
            const motors = movementToMotors(forwardSpeed, 0, turn);
            motor1 = motors.motor1;
            motor2 = motors.motor2;
            motor3 = motors.motor3;
            motor4 = motors.motor4;
          } else {
            // Facing away from goal - move forward straight
            const motors = movementToMotors(forwardSpeed, 0, 0);
            motor1 = motors.motor1;
            motor2 = motors.motor2;
            motor3 = motors.motor3;
            motor4 = motors.motor4;
      }
    }
        
        // #region agent log
        fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:831',message:'DEFENDING adjusting distance',data:{distanceError,goalAngle,motor1,motor2,motor3,motor4},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'C,D'})}).catch(()=>{});
        // #endregion
      } else {
        // At correct distance - strafe left/right along goal while facing opponent
        // With omni wheels, we can truly strafe sideways!
        
        // Calculate strafe direction: if ball is to the right of goal, strafe right; if left, strafe left
        // goalToBallAngle tells us where ball is relative to goal
        // Clamp to reasonable range to avoid extreme corners
        const clampedGoalToBallAngle = clamp(goalToBallAngle, -75, 75);
        
        // Strafe speed: proportional to how far ball is from center
        // Minimum speed to ensure we're always doing something
        const strafeSpeed = Math.max(clamp(Math_abs(clampedGoalToBallAngle) / 75, 0, 1) * 0.4, 0.1);
        const strafeDirection = clampedGoalToBallAngle > 0 ? 1 : (clampedGoalToBallAngle < 0 ? -1 : 0);
        
        // Turn to face opponent goal (if visible)
        const turnToOpponentGoal = opponentGoal.visible && opponentGoalAngle !== null 
          ? clamp(opponentGoalAngle / 50, -1, 1) * 0.3 
          : 0;
    
        // With omni wheels at 45° (diamond pattern from Arduino code):
        // Forward kinematics (verified from Arduino patterns):
        //   m1 = vx + vy + omega
        //   m2 = -vx + vy + omega
        //   m3 = vx - vy - omega
        //   m4 = -vx - vy - omega
        //   Where: vx = forward/backward (forward = +), vy = left/right (right = +), omega = rotation (CW = +)
        //
        // Desired movement:
        // - Forward: vx = small forward component to maintain distance (positive = forward)
        // - Strafe: vy = strafeSpeed * strafeDirection (positive = right)
        // - Turn: omega = turnToOpponentGoal (positive = CW)
        
        // Use strafeAtAngle to move along the arc at the calculated angle
        // This allows smooth arc movement at any angle (12°, 45°, etc.) while maintaining forward orientation
        // The angle is goalToBallAngle, which tells us where to move along the arc
        const arcMotors = strafeAtAngle(clampedGoalToBallAngle, strafeSpeed, turnToOpponentGoal);
        motor1 = arcMotors.motor1;
        motor2 = arcMotors.motor2;
        motor3 = arcMotors.motor3;
        motor4 = arcMotors.motor4;
        
        // #region agent log
        fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:912',message:'DEFENDING strafing along goal with omni wheels',data:{goalToBallAngle,clampedGoalToBallAngle,strafeSpeed,strafeDirection,turnToOpponentGoal,motor1,motor2,motor3,motor4,allZero:motor1===0&&motor2===0&&motor3===0&&motor4===0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,D'})}).catch(()=>{});
        // #endregion
      }
      
      return returnAction();
    }
    
    // Ball not visible - maintain position within 40cm
    // Small search movement if needed
    if (!ball.visible && ownGoal.visible) {
      // Stay in place or small search turn
      const turnSpeed = 0.2;
      turn(turnSpeed);
      return returnAction();
    }
    
    return returnAction();
  }
  
  // ============================================================
  // STATE: DEFLECTING (Push ball toward opponent goal)
  // ============================================================
  // Defensive check: Don't allow DEFLECTING if RESET_POSITION is active and not complete
  // TEST MODE: Disabled - always allow DEFENDING
  if (false && currentState === STATE.RESET_POSITION) {
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:760',message:'DEFLECTING blocked - RESET_POSITION still active',data:{resetDistanceMoved},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'BH'})}).catch(()=>{});
    // #endregion
    // RESET_POSITION should have been handled earlier, but if we somehow reach here,
    // don't allow DEFLECTING to execute - RESET_POSITION must complete first
    return returnAction();
  }
  
  if (currentState === STATE.DEFLECTING) {
    // Set target for display
    currentTarget = 'ball';
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:744',message:'DEFLECTING state active',data:{currentState,ballVisible:ball.visible,ballDist:ball.visible ? ball.distance : null,ownGoalVisible:ownGoal.visible,ownGoalDist:ownGoal.visible ? ownGoal.distance : null,lineFront:line_front,lineLeft:line_left,lineRight:line_right,lineRear:line_rear,ignoreLineDetection},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AI'})}).catch(()=>{});
    // #endregion
    
    const distanceFromGoal = ownGoal.visible ? ownGoal.distance : 999;
    const ballAngle = ball.angle_deg;
    const ballDist = ball.distance;
    
    // DEFLECTING: Push ball toward opponent goal while staying within 60cm of own goal
    // After kicking, return to DEFENDING
    
    // If ball lost or too far, transition back to DEFENDING
    if (!ball.visible || ballDist > 70) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:748',message:'DEFLECTING exiting to DEFENDING',data:{ballVisible:ball.visible,ballDist:ball.visible ? ball.distance : null,exitReason:!ball.visible ? 'ballLost' : 'ballTooFar'},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'K'})}).catch(()=>{});
      // #endregion
      currentState = STATE.DEFENDING;
      return returnAction();
    }
    
    // If too far from goal (>100cm), move back toward goal while deflecting
    if (distanceFromGoal > MAX_DEFLECTING_DISTANCE && ownGoal.visible) {
      // #region agent log
      fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:787',message:'DEFLECTING too far from goal, backing up',data:{distanceFromGoal,MAX_DEFLECTING_DISTANCE,ballAngle,ballDist},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AN'})}).catch(()=>{});
      // #endregion
      const goalAngle = ownGoal.angle_deg;
      // Move backward to return to goal area
      const backSpeed = -0.5;
      
      if (Math_abs(ballAngle) > 25) {
        // Turn toward ball while backing up
        const turn = clamp(ballAngle / 40, -1, 1) * 0.3;
        motor1 = backSpeed - turn;
        motor4 = backSpeed - turn;
        motor2 = backSpeed + turn;
        motor3 = backSpeed + turn;
      } else {
        // Ball in front - deflect while backing up
        let pushAngle = ballAngle;
        const opponentGoalAngle = opponentGoal.visible ? opponentGoal.angle_deg : null;
        if (opponentGoal.visible && opponentGoalAngle !== null) {
          pushAngle = ballAngle * 0.3 + opponentGoalAngle * 0.7;
        }
        const steer = clamp(pushAngle / 50, -0.15, 0.15);
        motor1 = backSpeed - steer;
        motor4 = backSpeed - steer;
        motor2 = backSpeed + steer;
        motor3 = backSpeed + steer;
        
        // Kick when very close to ball
        if (ballDist < 15) {
          kick = true;
        }
      }
      return returnAction();
    }
    
    // Within 100cm - push ball toward opponent goal
    const opponentGoalAngle = opponentGoal.visible ? opponentGoal.angle_deg : null;
    
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:822',message:'DEFLECTING approaching ball',data:{ballAngle,ballDist,distanceFromGoal,absBallAngle:Math_abs(ballAngle),opponentGoalVisible:opponentGoal.visible,opponentGoalAngle},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AO'})}).catch(()=>{});
    // #endregion
    
    if (Math_abs(ballAngle) > 25) {
      // Turn toward ball AND move forward to approach it
      const turn = clamp(ballAngle / 40, -1, 1) * 0.6;
      const forwardSpeed = 0.4; // Move forward while turning
      motor1 = forwardSpeed - turn;
      motor4 = forwardSpeed - turn;
      motor2 = forwardSpeed + turn;
      motor3 = forwardSpeed + turn;
    } else {
      // Ball is in front - push it toward opponent goal
      let pushAngle = ballAngle;
      if (opponentGoal.visible && opponentGoalAngle !== null) {
        // Push toward opponent goal (blend ball angle with opponent goal angle)
        pushAngle = ballAngle * 0.4 + opponentGoalAngle * 0.6;
      }
      
      // Move forward to push ball toward opponent goal
      const forwardSpeed = 0.5;
      const steer = clamp(pushAngle / 50, -0.3, 0.3);
      
      motor1 = forwardSpeed - steer;
      motor4 = forwardSpeed - steer;
      motor2 = forwardSpeed + steer;
      motor3 = forwardSpeed + steer;
      
      // Kick when ball is close enough
      if (ballDist < 20) {
        kick = true;
        // After kicking, return to DEFENDING
        // #region agent log
        fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:850',message:'DEFLECTING kicked, returning to DEFENDING',data:{ballDist,distanceFromGoal},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'L'})}).catch(()=>{});
        // #endregion
        currentState = STATE.DEFENDING;
      }
    }
    
    return returnAction();
  }
  
  // Ensure state is always valid - if somehow invalid, reset to DEFENDING
  if (!Object.values(STATE).includes(currentState)) {
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:861',message:'Invalid state detected, resetting to DEFENDING',data:{invalidState:currentState,validStates:Object.values(STATE)},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AG'})}).catch(()=>{});
    // #endregion
    currentState = STATE.DEFENDING;
  }
  
  // #region agent log
  fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:1076',message:'DEFENDER final return',data:{currentState,motor1,motor2,motor3,motor4,kick,allZero:motor1===0&&motor2===0&&motor3===0&&motor4===0},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C,D,E'})}).catch(()=>{});
  // #endregion
  
  return returnAction();
  } catch (error) {
    // #region agent log
    fetch('http://127.0.0.1:7244/ingest/e757a59f-ea0f-41f7-a3ef-6d61b5471d67',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'defender.js:867',message:'Strategy error caught, defaulting to DEFENDING',data:{errorMessage:error instanceof Error ? error.message : String(error),currentState},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'AL'})}).catch(()=>{});
    // #endregion
    // On any error, ensure we return a valid state (DEFENDING) instead of undefined
    currentState = STATE.DEFENDING;
    const result = { motor1: 0, motor2: 0, motor3: 0, motor4: 0, kick: false };
    result._state = STATE.DEFENDING;
    result._target = null;
    return result;
  }
}
